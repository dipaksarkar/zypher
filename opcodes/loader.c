#include <php_embed.h>
#include <zend_compile.h>
#include <zend_execute.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/**
 * Zypher Opcode Loader
 *
 * This loader reads binary opcode files generated by the Zypher encoder,
 * reconstructs the Zend opcode array, and executes it through the PHP engine.
 */

// Same structure as in encoder.c to ensure compatibility
typedef struct
{
    uint32_t opcode;
    uint32_t lineno;
    uint32_t op1_type;
    uint32_t op1_value;
    uint32_t op2_type;
    uint32_t op2_value;
    uint32_t result_type;
    uint32_t result_value;
} zypher_serialized_op;

// Debug level (0=minimal, 1=normal, 2=verbose)
#define ZYPHER_DEBUG_LEVEL 2

// Execution mode
#define EXEC_MODE_NORMAL 0    // Try full execution (may crash)
#define EXEC_MODE_DRY_RUN 1   // Simulate execution (safer, for analysis)

// Simple validity checks for opcode values
int is_valid_opcode(uint32_t opcode)
{
    // Check if opcode is within reasonable range for PHP opcodes
    return opcode < 256; // Most PHP opcodes are below this value
}

// Check if operand type is valid
int is_valid_operand_type(uint32_t type)
{
    // Common operand types in Zend Engine
    switch (type)
    {
    case IS_UNUSED:
    case IS_CONST:
    case IS_TMP_VAR:
    case IS_VAR:
    case IS_CV:
        return 1;
    default:
        return 0;
    }
}

/**
 * Debug function to print opcode details
 */
void debug_print_opcode(int index, const zypher_serialized_op *op)
{
    if (ZYPHER_DEBUG_LEVEL < 2)
        return;

    printf("Opcode[%d]: op=%u, line=%u, op1_type=%u, op1_val=%u, op2_type=%u, op2_val=%u, res_type=%u, res_val=%u\n",
           index, op->opcode, op->lineno,
           op->op1_type, op->op1_value,
           op->op2_type, op->op2_value,
           op->result_type, op->result_value);
}

/**
 * Create an empty, minimal op_array that can be built upon
 */
zend_op_array *create_minimal_op_array(const char *filename)
{
    zend_op_array *op_array = ecalloc(1, sizeof(zend_op_array));

    // Initialize with basic values
    op_array->type = ZEND_USER_FUNCTION;
    op_array->filename = zend_string_init(filename, strlen(filename), 0);
    op_array->fn_flags = ZEND_ACC_PUBLIC;
    op_array->last_var = 0;
    op_array->last = 0;
    op_array->last_literal = 0;

    // Initialize other important fields
    op_array->scope = NULL;
    op_array->function_name = NULL; // No function name for main code
    op_array->arg_info = NULL;
    op_array->num_args = 0;
    op_array->required_num_args = 0;
    op_array->cache_size = 0;
    op_array->last_try_catch = 0;

    return op_array;
}

/**
 * Analyze the opcodes to find the highest variable number used
 */
uint32_t find_max_var_number(zypher_serialized_op *opcodes, int count)
{
    uint32_t max_var = 0;

    for (int i = 0; i < count; i++)
    {
        zypher_serialized_op *op = &opcodes[i];

        if (op->op1_type == IS_VAR || op->op1_type == IS_TMP_VAR || op->op1_type == IS_CV)
        {
            if (op->op1_value > max_var)
                max_var = op->op1_value;
        }

        if (op->op2_type == IS_VAR || op->op2_type == IS_TMP_VAR || op->op2_type == IS_CV)
        {
            if (op->op2_value > max_var)
                max_var = op->op2_value;
        }

        if (op->result_type == IS_VAR || op->result_type == IS_TMP_VAR || op->result_type == IS_CV)
        {
            if (op->result_value > max_var)
                max_var = op->result_value;
        }
    }

    return max_var;
}

/**
 * Safely load all opcodes from the binary file into memory
 * Returns NULL on failure
 */
zypher_serialized_op *load_opcodes_from_file(const char *filename, int *count_out)
{
    FILE *fp = fopen(filename, "rb");
    if (!fp)
    {
        fprintf(stderr, "Error: Unable to open file '%s'\n", filename);
        return NULL;
    }

    // Get file size
    fseek(fp, 0, SEEK_END);
    long file_size = ftell(fp);
    fseek(fp, 0, SEEK_SET);

    if (file_size <= 0)
    {
        fprintf(stderr, "Error: Empty file\n");
        fclose(fp);
        return NULL;
    }

    // Calculate number of opcodes
    int count = file_size / sizeof(zypher_serialized_op);
    if (count <= 0 || file_size % sizeof(zypher_serialized_op) != 0)
    {
        fprintf(stderr, "Error: Invalid file format or size (%ld bytes)\n", file_size);
        fclose(fp);
        return NULL;
    }

    // Allocate memory for all opcodes
    zypher_serialized_op *opcodes = malloc(count * sizeof(zypher_serialized_op));
    if (!opcodes)
    {
        fprintf(stderr, "Error: Failed to allocate memory for opcodes\n");
        fclose(fp);
        return NULL;
    }

    // Read all opcodes at once
    size_t read_count = fread(opcodes, sizeof(zypher_serialized_op), count, fp);
    fclose(fp);

    if (read_count != count)
    {
        fprintf(stderr, "Error: Could not read all opcodes (read %zu of %d)\n", read_count, count);
        free(opcodes);
        return NULL;
    }

    // Validate opcodes if debug level high enough
    if (ZYPHER_DEBUG_LEVEL >= 1)
    {
        printf("Loaded %d opcodes, validating...\n", count);

        for (int i = 0; i < count; i++)
        {
            debug_print_opcode(i, &opcodes[i]);

            if (!is_valid_opcode(opcodes[i].opcode))
            {
                fprintf(stderr, "Warning: Opcode[%d] has invalid opcode number: %u\n",
                        i, opcodes[i].opcode);
            }

            if (!is_valid_operand_type(opcodes[i].op1_type))
            {
                fprintf(stderr, "Warning: Opcode[%d] has invalid op1 type: %u\n",
                        i, opcodes[i].op1_type);
            }

            if (!is_valid_operand_type(opcodes[i].op2_type))
            {
                fprintf(stderr, "Warning: Opcode[%d] has invalid op2 type: %u\n",
                        i, opcodes[i].op2_type);
            }

            if (!is_valid_operand_type(opcodes[i].result_type))
            {
                fprintf(stderr, "Warning: Opcode[%d] has invalid result type: %u\n",
                        i, opcodes[i].result_type);
            }
        }
    }

    *count_out = count;
    return opcodes;
}

/**
 * Reconstruct a zend_op_array from serialized opcodes with additional safeguards
 */
zend_op_array *reconstruct_op_array(zypher_serialized_op *serialized_opcodes, int count, const char *filename)
{
    if (!serialized_opcodes || count <= 0)
    {
        fprintf(stderr, "Error: Invalid opcode data\n");
        return NULL;
    }

    // Find highest variable number to allocate correct space
    uint32_t max_var = find_max_var_number(serialized_opcodes, count);
    if (ZYPHER_DEBUG_LEVEL >= 1)
    {
        printf("Found highest variable number: %u\n", max_var);
    }

    // Create an empty op_array
    zend_op_array *op_array = create_minimal_op_array(filename);
    if (!op_array)
    {
        fprintf(stderr, "Error: Failed to create op_array\n");
        return NULL;
    }

    // Allocate opcodes array
    op_array->opcodes = ecalloc(count, sizeof(zend_op));
    if (!op_array->opcodes)
    {
        fprintf(stderr, "Error: Failed to allocate memory for opcodes\n");
        zend_string_release(op_array->filename);
        efree(op_array);
        return NULL;
    }

    // Allocate literal table (always have at least one NULL literal as a fallback)
    op_array->literals = ecalloc(1, sizeof(zval));
    if (!op_array->literals)
    {
        fprintf(stderr, "Error: Failed to allocate memory for literals\n");
        efree(op_array->opcodes);
        zend_string_release(op_array->filename);
        efree(op_array);
        return NULL;
    }

    // Set up a NULL literal as a fallback
    ZVAL_NULL(&op_array->literals[0]);
    op_array->last_literal = 1;

    // Copy opcodes with validation
    for (int i = 0; i < count; i++)
    {
        zypher_serialized_op *s_op = &serialized_opcodes[i];
        zend_op *op = &op_array->opcodes[i];

        // Basic properties
        op->opcode = s_op->opcode;
        op->lineno = s_op->lineno;
        op->op1_type = s_op->op1_type;
        op->op2_type = s_op->op2_type;
        op->result_type = s_op->result_type;

        // Handle operand values
        switch (op->op1_type)
        {
        case IS_CONST:
            // Point to our dummy NULL literal
            op->op1.constant = 0;
            break;
        case IS_TMP_VAR:
        case IS_VAR:
        case IS_CV:
            op->op1.var = s_op->op1_value;
            break;
        default:
            op->op1.num = s_op->op1_value;
            break;
        }

        switch (op->op2_type)
        {
        case IS_CONST:
            op->op2.constant = 0;
            break;
        case IS_TMP_VAR:
        case IS_VAR:
        case IS_CV:
            op->op2.var = s_op->op2_value;
            break;
        default:
            op->op2.num = s_op->op2_value;
            break;
        }

        switch (op->result_type)
        {
        case IS_CONST:
            op->result.constant = 0;
            break;
        case IS_TMP_VAR:
        case IS_VAR:
        case IS_CV:
            op->result.var = s_op->result_value;
            break;
        default:
            op->result.num = s_op->result_value;
            break;
        }
    }

    // Set critical properties
    op_array->last = count;               // Number of opcodes
    op_array->last_var = max_var + 1;     // Number of variables
    op_array->T = op_array->last_var * 2; // Safe estimate for temp vars

    return op_array;
}

/**
 * Display basic information about the reconstructed op_array
 */
void print_op_array_info(zend_op_array *op_array)
{
    printf("\nOpcode array information:\n");
    printf("  Filename: %s\n", ZSTR_VAL(op_array->filename));
    printf("  Opcode count: %d\n", op_array->last);
    printf("  Variable count: %d\n", op_array->last_var);
    printf("  Literal count: %d\n", op_array->last_literal);

    // Show first few opcodes if verbose
    if (ZYPHER_DEBUG_LEVEL >= 1)
    {
        printf("\nFirst opcodes:\n");
        int show_count = op_array->last > 5 ? 5 : op_array->last;

        for (int i = 0; i < show_count; i++)
        {
            const zend_op *op = &op_array->opcodes[i];
            const char *opname = zend_get_opcode_name(op->opcode);
            printf("  [%d] %s (line %d)\n", i, opname ? opname : "UNKNOWN", op->lineno);
        }
        printf("\n");
    }
}

/**
 * Perform a "dry run" through opcodes - showing what would happen without actually executing
 */
void dry_run_opcodes(zend_op_array *op_array)
{
    printf("\nDry run of opcodes (showing what would be executed):\n");

    for (int i = 0; i < op_array->last; i++)
    {
        const zend_op *op = &op_array->opcodes[i];
        const char *opname = zend_get_opcode_name(op->opcode);

        printf("[%d] Line %d: %s", i, op->lineno, opname ? opname : "UNKNOWN");

        // Describe some common operations
        switch (op->opcode)
        {
        case 62: // ZEND_RETURN
            printf(" (End of script, returning)");
            break;
        case 40: // ZEND_PRINT
        case 136: // ZEND_ECHO
            printf(" (Output to screen)");
            break;
        case 68: // ZEND_NEW
            printf(" (Create new object)");
            break;
        case 60: // ZEND_DO_FCALL
            printf(" (Function call)");
            break;
        case 112: // ZEND_INIT_METHOD_CALL
            printf(" (Object method call)");
            break;
        case 8: // ZEND_ASSIGN
            printf(" (Variable assignment)");
            break;
        case 131: // ZEND_INCLUDE_OR_EVAL
            printf(" (Include/require operation)");
            break;
        }

        printf("\n");
    }

    printf("\nDry run completed - %d opcodes traversed\n", op_array->last);
}

/**
 * Main loader entry point
 */
int main(int argc, char **argv)
{
    int exec_mode = EXEC_MODE_DRY_RUN; // Default to safer dry run mode

    if (argc < 2)
    {
        fprintf(stderr, "Usage: %s <input.zypher> [options]\n", argv[0]);
        fprintf(stderr, "Options:\n");
        fprintf(stderr, "  --exec      Attempt full execution (may crash)\n");
        fprintf(stderr, "  --dry-run   Show opcode execution steps without executing (default)\n");
        return 1;
    }

    // Parse command-line options
    for (int i = 2; i < argc; i++)
    {
        if (strcmp(argv[i], "--exec") == 0)
        {
            exec_mode = EXEC_MODE_NORMAL;
        }
        else if (strcmp(argv[i], "--dry-run") == 0)
        {
            exec_mode = EXEC_MODE_DRY_RUN;
        }
        else
        {
            fprintf(stderr, "Unknown option: %s\n", argv[i]);
        }
    }

    const char *filename = argv[1];
    printf("Zypher Loader: Loading '%s'\n", filename);

    // Load opcodes from file
    int opcode_count = 0;
    zypher_serialized_op *serialized_opcodes = load_opcodes_from_file(filename, &opcode_count);

    if (!serialized_opcodes)
    {
        fprintf(stderr, "Failed to load opcodes from file.\n");
        return 1;
    }

    printf("Successfully loaded %d opcodes.\n", opcode_count);

    // Initialize PHP embedding
    php_embed_init(argc, argv);

    // Reconstruct the opcode array
    zend_op_array *op_array = NULL;

    zend_try
    {
        op_array = reconstruct_op_array(serialized_opcodes, opcode_count, filename);
        if (!op_array)
        {
            fprintf(stderr, "Failed to reconstruct opcode array.\n");
            php_embed_shutdown();
            free(serialized_opcodes);
            return 1;
        }

        // Print information about the reconstructed op array
        print_op_array_info(op_array);

        // Clear error state before execution
        if (EG(exception))
        {
            // Just clear the exception without trying to display it
            EG(exception) = NULL;
        }

        if (exec_mode == EXEC_MODE_DRY_RUN)
        {
            // Run the safer dry run mode - just analyze what would happen
            dry_run_opcodes(op_array);
        }
        else
        {
            // Warning about limitations
            printf("\nWARNING: This is a demonstration loader attempting full execution.\n");
            printf("Without complete context (literals, variable names, etc.), execution may fail.\n\n");

            // Try to execute the opcodes
            printf("Attempting to execute opcodes...\n");

            // Create return value container
            zval result;
            ZVAL_NULL(&result);

            // Execute the opcodes
            zend_execute(op_array, &result);

            // Display result if not NULL
            if (Z_TYPE(result) != IS_NULL)
            {
                printf("\nExecution result:\n");
                zend_print_zval_r(&result, 0);
                printf("\n");
            }

            // Clean up
            zval_ptr_dtor(&result);
        }

        destroy_op_array(op_array);
        efree(op_array);
    }
    zend_catch
    {
        printf("\nError encountered during execution.\n");
        if (op_array)
        {
            destroy_op_array(op_array);
            efree(op_array);
        }
    }
    zend_end_try();

    // Clean up
    php_embed_shutdown();
    free(serialized_opcodes);

    printf("Loader execution completed.\n");
    return 0;
}
